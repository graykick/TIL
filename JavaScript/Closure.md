# Closure
Closure는 굉장히 재미있는 현상이다.
간단히 설명하자면, 내부함수가 외부함수의 환경을 참조(복사X 참조O)하는 것이다.

이는 예로 보는것이 좋은데, 사용하는 예에 앞서 클로저를 모르는 사람이 자신도 모르게 클로저코드를 작성하였을때 발생하는 **문제**를 일으키는 예를 보면 이해하기가 더 좋다.

```
for (var i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100*i);
}
```
위의 코드의 출력결과를 생각해보자.
대답은 둘로 나뉜다. 클로저를 아는사람의 답과 모르는 사람의 답.
아는 사람의 답은 ** 10을 10번 출력한다. ** 이다.
반면 모르는 사람의 답은 ** 0부터 9까지 100ms초 간격으로 출력한다. ** 이다.
실행해보면 알겠지만, 답은  ** 10을 10번 출력한다. ** 이다.

이유는 클로저 때문이며, 내부함수가 외부함수의 환경을 참조(복사X 참조O)했기 때문이다.

이제는 당연하겠지만, for문이 10번 도는 속도는 100ms보다 빠르다.
즉, 100ms가 경과하여 i를 출력할때는 이미 for문이 10번 돌아 i는 10이 되어있는 상태이다.

setTimeout의 콜백은 내부함수이다. 그리고 i는 그 내부함수의 외부함수의 스코프에 속해있다.
즉, 내부함수인 setTimeout의 콜백함수는 자신이 출력해야할 ** i **를 외부함수에서 ** 참조 **한다. 그래서 모두 10이 출력되는 결과가 나오게 된 것이다.

이를 해결하는 방법은 최소 2가지이다.
- 새로운 클로저를 만든다. <br/>
간단하다. 해당 순간의 i를 새로운 외부함수의 스코프에 포함되도록 하고, setTimeout의 콜백함수가 해당 외부함수를 참조하도록 한다. 복잡한것 같지만 간단하다.
```
for (var i = 0; i < 10; i++) {
  (function(innerI) {
    setTimeout(function() {
      console.log(innerI);
    }, 100);
  })(i);
}
```

- 새로운 변수타입인 let을 사용한다. <br/>
가장 간단한 방법이다. var가 아닌, let을 사용하면 된다.
이 let은 간단히 설명하면, 함수스코프가아닌 블록스코프를 사용하는 변수이다.
```
for (let i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100*i);
}
```
클로저를 사용해서 싱글턴이나, 팩토리패턴을 구현할 수도 있다.
https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures 참고

함수안에서 함수를 사용하게 될 경우는 굉장히 많은데, 이때 주의하지 않으면 굉장히 고생할 수 있다.


https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures
